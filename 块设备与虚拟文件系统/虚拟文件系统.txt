虚拟文件系统所隐含的思想是把表示很多不同种类文件系统的共同信息放入内核；其中有一个字段或函数来支持Linux所支持的所有实际文件系统所提供的任何操作。

五个Unix标准文件类型：普通文件、目录文件、符号链接文件、设备文件、管道文件


VFS支持的文件系统分磁盘文件系统、网络文件系统和特殊文件系统这三大类

VFS所隐含的主要思想在于引入了一个通用的文件模型（common file model），这个模型能够表示所有支持的文件系统。要实现每个具体的文件系统，必须将其物理组织结构转换成虚拟文件系统的通用文件模型。

从本质上来说，Linux内核不能对一个特定的函数进行硬编码来执行诸如read()或ioctl()这样的操作，而是对每个操作都必须使用一个指针，指向要访问的具体文件系统的适当函数。内核负责把一组合适的指针分配给与每个打开文件相关的file变量，然后负责调用针对每个文件系统的函数(由存放在内核内存中的file结构中的f_op字段描述，例如file->f_op->read(...))

通用文件模型由下列对象类型组成：
	超级块对象(superblock object)：存放已安装文件系统的有关信息。对基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件系统控制块(filesystem control block)。所有的超级块对象都以双向链表的形式链接在一起。链表中第一个元素用super_blocks变量来表示，而超级块对象的s_list字段存放指向链表相邻的指针。sb_lock自旋锁保护链表免受多处理器上的同时访问。

	索引节点对象(inode object)：存放关于具体文件的一般信息。对基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件控制块(file control block)。每个索引节点对象都有一个索引节点号，这个节点号唯一地标识文件系统中的文件。文件系统处理文件所需要的所有信息都存放在一个名为索引节点的数据结构(struct inode)中。文件名可以随便改，但是索引节点对文件是唯一的，并且随文件的存在而存在。

	文件对象(file object)：存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在于内核内存中。存放在文件对象中的主要信息是文件指针，及文件中当前的位置，下一个操作将在该位置发生。由于几个进程可能同时访问同一文件，因此文件指针必须存放在文件对象而不是索引节点对象中。

	目录项对象(dentry object)：存放目录项（也就是文件的特定名称）与对应文件进行链接的有关信息。每个磁盘文件系统都以自己特有的方式将该类信息存放在磁盘上。VFS把每个目录看作由若干子目录和文件组成的一个普通文件。对于进程查找的路径名中每个分量，内核都为其创建一个目录项对象；目录项对象将每个分量与其对应的索引节点相联系。目录项对象存放在名为dentry_cache的slab分配器高速缓存中，目录项对象的创建和删除是通过kmem_cache_alloc()和kmem_cache_free()实现的。

每个文件系统都有其自己的文件操作集合，执行诸如读写这样的操作。当内核将一个索引节点从磁盘装入内存时，就会把指向这些文件操作的指针存放在file_operatons结构中，而该结构的地址存放在该索引节点对象的i_fop字段中。当进程打开这个文件时，VFS就用存放在索引节点中的这个地址初始化新文件对象的f_op字段，使得对文件操作的后续调用能够使用这些函数。如果需要，VFS随后也可以通过在f_op字段存放一个新值而修改文件操作的集合。

VFS除了能为所有文件系统的实现提供一个通用接口外，还具有另一个与系统性能相关的重要作用。最常使用的目录项对象被放在所谓目录项高速缓存(dentry cache)的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。

硬件高速缓存是一个静态RAM，它加快了直接对慢速动态RAM的请求。
内存高速缓存是一种软体机制，引入它是为了绕过内存分配器。

每个VFS对象(即通用文件模型的组成对象)都存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法表的指针。内核可以动态地修改对象的方法，因此可以为对象建立专用的行为。

Linux使用目录项高速缓存，它由两种类型的数据结构组成：
	一个处于正在使用、未使用或负状态的目录项对象；
	一个散列表，从中能够快速获取与给定的文件名和目录名对应的目录项对象。同样，如果访问的对象不在目录项高速缓存中，则散列函数返回一个空值。
目录项高速缓存的作用还相当于索引节点高速缓存(inode cache)的控制器。

与进程相关的文件用fs_struct和files_struct这两个结构体进行描述，分别存放在进程描述符的fs字段和files字段。当内核开始使用一个文件对象时，内核提供fget()函数以供调用。这个函数接收文件描述符fd(files_struct中的字段)作为参数，返回在current->files->fd[fd]中的地址，即对应文件对象的地址，如果没有任何文件与fd对应，则返回NULL。当内核控制路径完成对文件对象的使用时，调用内核提供的fput()函数。

特殊文件系统不限于物理块设备。然而，内核给每个安装的特殊文件系统分配一个虚拟的块设备，让其主设备号为0而次设备号具有任意值(每个特殊文件系统有不同的值)。

每个注册的文件系统都用一个类型为file_system_type的对象来表示。其中实现了读超级块的方法get_sb()和删除超级块的方法kill_sb()。所有文件系统类型的对象都插入到一个单向链表中，由变量file_systems指向链表的第一个元素。相关的三个函数register_filesystem()、unregidter_filesystem()和get_fs_type()。

在传统的Unix系统中，只有一个已安装文件系统树：从系统的根目录文件系统开始，每个进程通过指定合适的路径可以访问已安装文件系统中的任何文件。从这个方面考虑，Linux 2.6更加精确：每个进程可拥有自己的一安装文件系统树――叫做进程的命名空间(namespace)。

已安装文件系统由vfsmount结构描述。

mount()系统调用被用来安装一个普通的文件系统；它的服务例程sys_mount()作用于以下参数：
	1）文件系统所在的设备文件的路径名，或者如果不需要的话就为NULL（例如，当要安装的文件系统是基于网络时）；
	2）文件系统被安装其上的某个目录的目录路径名（安装点）；
	3）文件系统的类型，必须是已注册文件系统的名字；
	4）安装标志；
	5）指向一个与文件系统相关的数据结构的指针（也许为NULL）。
sys_mount()函数把参数的值拷贝到临时内核缓冲区，获取大内核锁，并调用do_mount()函数。一旦do_mount()返回，则这个服务例程释放大内核锁并释放临时内核缓冲区。

安装跟文件系统分两个阶段，如下所示：
	1.内核安装特殊rootfs文件系统，该文件系统仅提供一个作为初始安装点的空目录；
	2.内核在空目录上安装实际跟文件系统。
	
对在初始目录的索引节点进行处理的过程中，代码要检查与第一个名字匹配的目录项，以获得相应的索引节点。然后，从磁盘读出包含那个索引节点的目录文件，并检查与第二个名字匹配的目录项，以获得相应的索引节点。对于包含在路径中的每个名字，这个过程反复执行。

文件对象(struct file)中的f_op字段指向索引节点对象(struct inode)的i_fop，而i_fop指向的就是驱动程序所实现的file_operations结构。其中inode中的i_rdev字段也标识了对应设备的设备号。

附录相关命令：
挂载ramdisk模拟的块设备：mount -t ramfs /dev/* /tmp/*
